import os
import networkx as nx
import pandas as pd
from scipy import sparse
import seaborn as sns
import matplotlib.pyplot as plt

from SIReNet.sparse_graph_wutils import SparseGraph_wutils
from SIReNet.numba_samplers import Binomial






import numpy as np

class EpidemicsGraph(SparseGraph_wutils):

    '''

     Attributes
    ___________

    todo complete EpidemicsGraph attributes

    Grosso modo: per infetti, recovered e morti viene memorizzata
    vita morte e miracoli. Come serie storiche e valori attuali


    Methods
    __________

    - initialize_individual_factors(p_comorbidities: float in [0,1], p_mitigating: float in [0,1])
        Initializes for each node two values: comorbidities and mitigating factors. High values
        of comorbidities increase the probability that a specific nodes becomes infected (the
        reverse holds for mitigating factors). These two values are generated by a geometric distribution
        and p_mitigating and p_comorbidities are the parameters used to specify such distributions

    - start_infection(contagion_probability: float in [0,1])
        Initializes the infection in the graph. Each node ha a probablity contagion_probability of becoming infect

    - propagate_infection( todo complete propagate_infection documentation)



    '''






    def __init__(self,pop_size=1000,node_name='Paperopolis'):

        #inhertis from SparseGraph_wutils
        super().__init__(pop_size,node_name)

        # EPIDMIOLOGICAL DATA

        # overall parameters
        self.iterations = 0

        # Current values
        self.infect_scores = None
        self.infect_scores_modified = None
        self.infect_probs = None
        self.infect = None
        self.infect_number = None
        self.infect_new = None

        self.recovery_probs = None
        self.recovery = []
        self.recovery_number = None

        self.death_probs = None
        self.death = []
        self.death_number = None

        # Time series
        # for infection we should use matrix and concatenate rows
        self.infect_scores_over_time = None
        self.infect_scores_modified_over_time = None
        self.infect_probs_over_time = None
        self.infect_indexes_over_time = []
        self.infect_over_time = np.array([])

        # recovered insted have variable length, use a list
        self.recovery_probs_over_time = []
        self.recovery_indexes_over_time = []
        self.recovery_over_time = np.array([])

        # same for the deaths
        self.death_probs_over_time = []
        self.death_indexes_over_time = []
        self.death_over_time = np.array([])

    #############################################################################

    def initialize_individual_factors(self, p_comorbidities=0.7, p_mitigating=0.4):

        #we draw comorbidities and mitigating factors for each node
        self.comorbidities_factor = np.random.geometric(p_comorbidities, size=self.pop_size) - 1
        self.mitigating_factor = np.random.geometric(p_mitigating, size=self.pop_size) - 1

    #############################################################################

    def start_infection(self, contagion_probability=0.002):

        self.infect = np.random.binomial(n=1, p=contagion_probability, size=(self.pop_size))
        # bool type is memory efficient and handy for updating infects later
        self.infect = self.infect.astype(np.bool)

        #total number of infecrts
        self.infect_number = np.sum(self.infect)

        # increment iterations
        self.iterations += 1

        # save indexes of infect patients
        self.infect_indexes_over_time.append(np.argwhere(self.infect).ravel())

        self.infect_over_time = np.append(self.infect_over_time, self.infect_number)
        self.recovery_over_time = np.append(self.recovery_over_time,0)
        self.death_over_time = np.append(self.death_over_time,0)

        print('{} people have been infected'.format(self.infect_number))

    #############################################################################

    def propagate_infection(self, mu=3, w_comorb=1, w_mitig=1,
                            p_recovery=0.7, p_death=0.7,
                            time_resolution=1):

        from scipy import stats

        # RECOVERED

        # here the higher the prob the faster the recovery
        # higher probs concentrare the probability mass in the first
        # points of the support

        #this list will contain the indexes of nodes that need to be removed
        #from the graph
        remove_from_graph = []

        ##########################################################
        ######################## RECOVERIES ######################

        if (self.infect_number > 0):

            #we firstly need to extract the indexes of infects from last iteration
            infect_indexes = self.infect_indexes_over_time[-1]

            #personal disposition: higher values of personal pred denote healthy patients
            personal_predisposition = self.mitigating_factor[infect_indexes] - self.comorbidities_factor[infect_indexes]

            #we trasform personal predisposition into a probability through a cdf:
            #higher personal_predisposition = higher probablity of recovery
            # todo patients with negative personal predisposition can never recover, maybe this needs to be addressed
            self.recovery_probs = stats.geom.cdf(personal_predisposition, p=p_recovery)*time_resolution

            recovery_sampler = Binomial(probs=self.recovery_probs)

            new_recovery = recovery_sampler.sample()

            new_recovery_indexes = infect_indexes[new_recovery == 1]

            self.recovery_number = np.sum(new_recovery)
            self.recovery.extend(new_recovery_indexes)

            # use this later for deaths (infects not recovered)
            infect_indexes = infect_indexes[new_recovery == 0]

            # time series
            self.recovery_probs_over_time.append(self.recovery_probs)
            self.recovery_indexes_over_time.append(new_recovery_indexes)
            self.recovery_over_time = np.append(self.recovery_over_time, self.recovery_number)

            # recovered patients become immune and should be removed from
            # the contact graph
            remove_from_graph.extend(new_recovery_indexes)
            self.infect[new_recovery_indexes] = 0

            remaining_infects = len(infect_indexes)

        else:

            remaining_infects = 0

        ##########################################################
        ########################## DEATHS ########################

        #mostly the same as above, for deaths

        if (remaining_infects > 0):
            # switch the side of comorbidities and mitigating factors and take
            # the remaining infects
            personal_predisposition = -self.mitigating_factor[infect_indexes] + self.comorbidities_factor[
                infect_indexes]

            # todo same problem of recoveries, who has negative predisposition won't die
            self.death_probs = stats.geom.cdf(personal_predisposition, p=p_death)*time_resolution

            death_sampler = Binomial(probs=self.death_probs)

            new_death = death_sampler.sample()

            new_death_indexes = infect_indexes[new_death == 1]

            self.death_number = np.sum(new_death)
            self.death.append(new_death_indexes)

            # time series
            self.death_probs_over_time.append(self.death_probs)
            self.death_indexes_over_time.append(new_death_indexes)
            self.death_over_time = np.append(self.death_over_time, self.death_number)

            # deaths should be removed from the graph
            remove_from_graph.extend(new_death_indexes)
            self.infect[new_death_indexes] = 0


        # we use this matrix multiplication to remove dead and recovered nodes
        if (len(remove_from_graph) > 0):

            removal_matrix = sparse.identity(self.pop_size).todok()

            for i in remove_from_graph:
                removal_matrix[i, i] = 0

            self.adjacency = self.adjacency.dot(removal_matrix)
            self.adjacency = self.adjacency.transpose().dot(removal_matrix)
            self.adjacency = self.adjacency.todok()

            #after the graph has been updated, the common_neighbors matrix needs to be recomputed
            self.compute_common_neighbors()


        ########################################################
        ####################### INFECTIONS #####################

        modified_adjacency = self.adjacency.copy()
        modified_adjacency.setdiag(1)

        #we weight the adjacency through the common_neighbors matrix
        update_matrix = self.common_neighbors.multiply(modified_adjacency)

        #compute infection scores as dot product
        self.infect_scores = update_matrix.dot(self.infect)

        # computational trick to avoid that 0 score indiv have positive prob
        # in this step we also add individual factors in the infection score
        self.infect_scores_modified = np.where(self.infect_scores == 0, -1,
                                               self.infect_scores + w_comorb * self.comorbidities_factor - w_mitig * self.mitigating_factor)

        #we trasnform the infection score in a probability through a cdf
        #higher values corresponds to higher infection probabilities
        # todo maybe a different distribution instead of poisson?
        self.infect_probs = stats.poisson.cdf(k=self.infect_scores_modified, mu=mu)*time_resolution

        infect_sampler = Binomial(probs=self.infect_probs)

        self.infect_new = infect_sampler.sample()

        # we use bolean algebra to update the infects
        self.infect = self.infect + self.infect_new.astype(np.bool)

        # STATS ABOUT CONTAGION

        # increment iterations
        self.iterations += 1

        # save indexes of infect patients
        self.infect_indexes_over_time.append(np.argwhere(self.infect).ravel())

        self.infect_number = np.sum(self.infect)
        self.infect_over_time = np.append(self.infect_over_time, self.infect_number)

        if (self.infect_scores_over_time is None):

            self.infect_scores_over_time = self.infect_scores
            self.infect_scores_modified_over_time = self.infect_scores_modified
            self.infect_probs_over_time = self.infect_probs

        else:

            self.infect_scores_over_time = np.vstack([self.infect_scores_over_time, self.infect_scores])

            self.infect_scores_modified_over_time = np.vstack(
                [self.infect_scores_modified_over_time, self.infect_scores_modified])

            self.infect_probs_over_time = np.vstack([self.infect_probs_over_time, self.infect_probs])


    #############################################################################

    def export_graph(self, giant_component=True):

        if (giant_component):
            self.build_nx_graph()
            self.build_giant_component()

            out_adjac = nx.convert_matrix.to_scipy_sparse_matrix(self.giant_component, format='csr')
            print(os.getcwd()+'/adjacency.npz')
            sparse.save_npz(os.getcwd()+'/adjacency.npz',out_adjac)

            out_features_indexes = list(self.giant_component.nodes)

            out_comorbidities = self.comorbidities_factor[out_features_indexes]
            out_mitigating = self.mitigating_factor[out_features_indexes]
            out_labels = self.infect[out_features_indexes]

            out_df =pd.DataFrame()
            out_df['comorbidities'] = out_comorbidities
            out_df['mitigating'] = out_mitigating
            out_df['labels'] = out_labels
            out_df.index = out_features_indexes

            out_df.to_csv(os.getcwd()+'/node_features.csv')

        # todo complete with the code for the full graph

    #############################################################################

    def propagation_stats(self):

        from scipy import stats

        ####Monitoring
        print('-- EPIDEMICS --')
        print('Actual number of infect people: {}'.format(self.infect_number))
        print('New Recovered: {}'.format(self.recovery_number))
        print('New Deaths: {}'.format(self.death_number))
        print('New Infects: {}'.format(self.infect_number - self.infect_over_time[-2]))
        print('\n')

        print('-- MODEL DYNAMICS --')

        ##Scores

        print('- Scores')

        scores_stats = stats.describe(self.infect_scores)
        scores_quantiles = np.percentile(self.infect_scores, [15, 25, 50, 75, 90])

        print('Min score:', scores_stats[1][0])
        print('Max score:', scores_stats[1][1])
        print('Mean score:', scores_stats[2])
        print('Variance:', scores_stats[3])
        print('Skewness:', scores_stats[4])
        print('\n')
        print('15th percentile:', scores_quantiles[0])
        print('25th percentile:', scores_quantiles[1])
        print('50th percentile:', scores_quantiles[2])
        print('75th percentile:', scores_quantiles[3])
        print('90th percentile:', scores_quantiles[4])

        # print('Percentiles: 15th = {} \t 25th = {} \t 50th = {} \t 75th = {} \t 90th = {}'.format(scores_quantiles))

        fig = plt.figure(figsize=(10, 3), dpi=150)
        plt.hist(self.infect_scores)
        # sns.distplot(self.infection_scores,norm_hist=False)
        plt.title("Score distribution")
        plt.show()

        ##Probs
        print('\n')
        print('- Probs')

        prob_stats = stats.describe(self.infect_probs)
        prob_quantiles = np.percentile(self.infect_probs, [15, 25, 50, 75, 90])

        print('Min score:', prob_stats[1][0])
        print('Max score:', prob_stats[1][1])
        print('Mean score:', prob_stats[2])
        print('Variance:', prob_stats[3])
        print('Skewness:', prob_stats[4])
        print('\n')
        print('15th percentile:', prob_quantiles[0])
        print('25th percentile:', prob_quantiles[1])
        print('50th percentile:', prob_quantiles[2])
        print('75th percentile:', prob_quantiles[3])
        print('90th percentile:', prob_quantiles[4])

        # print('Percentiles: 15th = {} \t 25th = {} \t 50th = {} \t 75th = {} \t 90th = {}'.format(scores_quantiles))

        fig2 = plt.figure(figsize=(10, 3), dpi=150)
        plt.hist(self.infect_probs)
        plt.title("Probs distribution")
        plt.show()

    #############################################################################

    def iterations_summary(self):

        summary_df = pd.DataFrame()

        summary_df['iterations'] = list(range(self.iterations))
        summary_df['infected'] = self.infect_over_time
        summary_df['recovered'] = np.cumsum(self.recovery_over_time)
        summary_df['deaths'] = np.cumsum(self.death_over_time)

        susceptible = np.ones(self.iterations)*self.pop_size
        susceptible = susceptible-summary_df[['infected','recovered','deaths']].sum(axis=1).values

        summary_df['susceptible'] = susceptible

        sns.lineplot(data=summary_df[['infected','recovered','deaths']])



